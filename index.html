<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>TechStudy — Subjects → Topics → Chunks — Notes (SQLite + IndexedDB)</title>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<style>
:root{--bg:#0f1220;--card:#181c2f;--ink:#eef1ff;--muted:#9aa3c7;--line:#2a3052;--ok:#7bd88f;--bad:#ff7575;--accent:#6ca8ff}
*{box-sizing:border-box} html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
.wrap{max-width:1200px;margin:0 auto;padding:12px}
h1{font-size:18px;margin:0 0 12px}
.tag{display:inline-block;font-size:12px;background:#0b1128;border:1px solid var(--line);padding:2px 8px;border-radius:10px;margin-left:8px}
.app{display:grid;grid-template-columns:420px 1fr;gap:16px}
@media(max-width:960px){.app{grid-template-columns:1fr}}
.panel{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
input[type=text],input[type=url],input[type=password]{width:100%;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#0b1020;color:var(--ink)}
button{padding:10px 14px;border:0;border-radius:14px;background:var(--accent);color:#081225;font-weight:600;cursor:pointer}
button.ghost{background:#232a48;color:var(--ink)} button.warn{background:var(--bad);color:#200} button.slim{padding:6px 10px;border-radius:10px}
hr{border:0;border-top:1px dashed var(--line);margin:12px 0}
.subject{border:1px dashed var(--line);border-radius:12px;padding:12px;margin:10px 0}
.subject>header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
.subject h2{margin:0;font-size:18px}
.subject.collapsed .subject-body{display:none}
.topic{border:1px dashed var(--line);border-radius:12px;padding:10px;margin:10px 0}
.topic>header{display:flex;align-items:center;justify-content:space-between}
.topic h3{margin:0;font-size:16px;cursor:pointer}
.topic.collapsed .chunks{display:none}
.chunks{margin:8px 0 0 0;display:flex;gap:6px;flex-wrap:wrap}
.chunk-pill{background:#0e1330;border:1px solid var(--line);padding:6px 10px;border-radius:10px;cursor:pointer}
.details header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
.section{margin-top:8px}
.scroll-x{display:flex;gap:10px;overflow-x:auto;padding-bottom:8px}
.card{border:1px solid var(--line);border-radius:12px;padding:8px;background:#0f1530;min-width:220px}
.card img.preview{display:block;max-height:160px;border-radius:8px;cursor:zoom-in}
.card .thumbs{display:flex;gap:6px;overflow-x:auto;margin-top:6px}
.card .thumbs img{height:44px;border-radius:6px;border:1px solid var(--line);cursor:pointer}
.small{font-size:12px;color:var(--muted)}
input[type=file]{display:none}
.filelabel{display:inline-block;padding:10px 14px;border-radius:14px;background:#7bd88f;color:#102b18;font-weight:700;cursor:pointer}
a.link{color:#8fb5ff;text-decoration:none}
.iconbtn{background:#232a48;color:var(--ink);border-radius:10px;padding:6px 10px}
.icon{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
/* Lightbox */
.lightbox{position:fixed; inset:0; background:rgba(0,0,0,.92); display:none; z-index:9999}
.lightbox.show{display:block}
.lightbox-close{position:fixed; top:10px; right:10px; background:#fff; border:0; border-radius:999px; width:36px; height:36px; font-weight:900; cursor:pointer; z-index:10001}
.lightbox .viewport{position:absolute; inset:0; overflow:auto; -webkit-overflow-scrolling:touch; padding:16px; touch-action:auto; z-index:10000}
.lightbox .stack{display:flex; flex-direction:column; gap:12px; transform-origin:top left}
.lightbox .stack img{max-width:95vw; height:auto; display:block; border-radius:8px}
.lightbox.zoomed .stack{ transform:scale(var(--z,1)); }

/* === PDF Viewer Modal (new) === */
#pdfModal{position:fixed;inset:0;background:#000a;backdrop-filter:blur(2px);display:none;z-index:9998}
#pdfBox{position:absolute;inset:40px 20px 20px 20px;background:#0f1117;border-radius:12px;overflow:hidden;display:flex;flex-direction:column}
#pdfHdr{padding:8px 12px;border-bottom:1px solid var(--line);display:flex;gap:8px;align-items:center}
#pdfHdr .title{color:var(--ink);font-weight:700}
#pdfHdr .meta{margin-left:auto;color:var(--muted)}
#pdfViewer{flex:1;overflow:auto;background:#0b1128;padding:12px 0}
.page{margin:12px auto;max-width:900px;background:#111;box-shadow:0 2px 10px #0006}
.page canvas{display:block;width:100%;height:auto}
.sentinel{text-align:center;color:#aab;padding:16px 0}
</style>
</head>
<body>
<div class="wrap">
  <h1>
    TechStudy — Subjects → Topics → Chunks — Notes (SQLite + IndexedDB)
    <span id="dbStatus" class="tag">DB: starting…</span>
    <span id="netTag" class="tag">Online</span>
  </h1>

  <div class="app">
    <div class="panel" id="tree">
      <div class="row">
        <input id="newSubject" type="text" placeholder="New subject name"/>
        <button id="addSubject">+ Subject</button>
      </div>

      <!-- CouchDB panel -->
      <div class="subject">
        <header><h2 style="margin:0">CouchDB Sync</h2></header>
        <div class="row">
          <input id="couchUrl" type="url" placeholder="https://couch.techstudy.me"/>
          <input id="couchDb" type="text" placeholder="db name (engineering)"/>
        </div>
        <!-- Hidden creds (DB is open). Remove style to show again. -->
        <div class="row" id="credsRow" style="display:none">
          <input id="couchUser" type="text" placeholder="user"/>
          <input id="couchPass" type="password" placeholder="password"/>
        </div>
        <div class="row">
          <button class="ghost slim" id="couchSave">Save</button>
          <button class="ghost slim" id="couchTest">Test</button>
          <button id="couchSync">Sync now</button>
          <button class="ghost slim" id="couchPull">Pull now</button>
        </div>
        <div class="small" id="couchMsg"></div>
      </div>
      <!-- /CouchDB panel -->

      <div id="subjects"></div>
    </div>

    <div class="panel details">
      <header>
        <div>
          <div class="tag" id="scopeTag">Nothing selected</div>
          <h2 id="detailTitle" style="margin:.3rem 0 0 0"></h2>
        </div>
        <div class="row" id="renameDeleteBtns" style="display:none">
          <button class="ghost slim" id="renameBtn">Rename</button>
          <button class="warn slim" id="deleteBtn">Delete</button>
        </div>
      </header>

      <div id="detailBody" style="display:none">
        <div class="section">
          <h3>Image notes</h3>
          <div class="row">
            <label class="filelabel" for="imgInput">+ Add images</label>
            <input id="imgInput" type="file" accept="image/*" multiple/>
            <span class="small">Images are stored privately in IndexedDB</span>
          </div>
          <div id="imageList" class="scroll-x"></div>
        </div>
        <hr/>
        <div class="section">
          <h3>PDF links</h3>
          <div class="row">
            <input id="pdfTitle" type="text" placeholder="PDF title (e.g., Syllabus page)"/>
            <input id="pdfUrl" type="url" placeholder="https://...pdf or Google Drive link/ID"/>
            <button id="addPdf">+ Link</button>
          </div>
          <div id="pdfList"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Image Lightbox (unchanged) -->
<div id="lightbox" class="lightbox" aria-hidden="true">
  <button class="lightbox-close" aria-label="Close">×</button>
  <div class="viewport"><div class="stack" id="lbStack"></div></div>
</div>

<!-- NEW: PDF Viewer Modal -->
<div id="pdfModal" aria-hidden="true">
  <div id="pdfBox">
    <div id="pdfHdr">
      <button id="pdfClose" class="ghost slim">Close</button>
      <div class="title" id="pdfTitleBar">PDF</div>
      <div class="meta" id="pdfMeta">Loading…</div>
    </div>
    <div id="pdfViewer"></div>
  </div>
</div>

<script>
/* Register the TechStudy SW */
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.techstudy.js', { scope: './' }).catch(()=>{});
}
</script>

<script type="module">
(async () => {
  /* ---------- Status + utils ---------- */
  const statusEl = document.getElementById('dbStatus');
  const netTag = document.getElementById('netTag');
  const setStatus = (t, ok=true) => {
    statusEl.textContent = t;
    statusEl.style.borderColor = ok ? 'var(--line)' : 'var(--bad)';
    if (ok && t.includes('Saved')) setTimeout(()=>{ statusEl.textContent = 'DB: OK (IndexedDB)'; }, 800);
  };
  const setNet = () => netTag.textContent = navigator.onLine ? 'Online' : 'Offline';
  setNet(); window.addEventListener('online', setNet); window.addEventListener('offline', setNet);
  const esc = s => (s??'').replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"}[m]));

  /* ---------- Robust sql.js loader (local → CDN fallback) ---------- */
  function loadScript(url){
    return new Promise((resolve,reject)=>{
      const s=document.createElement('script'); s.src=url; s.async=true;
      s.onload=resolve; s.onerror=()=>reject(new Error('script load failed: '+url));
      document.head.appendChild(s);
    });
  }
  const SQL_CANDIDATES = [
    { js: './lib/sqljs/sql-wasm.js', wasm: './lib/sqljs/sql-wasm.wasm' },
    { js: 'https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/sql-wasm.js',
      wasm: 'https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/sql-wasm.wasm' }
  ];
  let SQL = null;
  for (const src of SQL_CANDIDATES) {
    try {
      await loadScript(src.js);
      SQL = await window.initSqlJs({ locateFile: () => src.wasm });
      break;
    } catch (err) {
      console.warn('sql.js load failed from', src.js, err);
    }
  }
  if (!SQL) { setStatus('DB init failed: could not load sql.js', false); throw new Error('sql.js not available'); }

  /* ---------- IndexedDB (TechStudy namespace) ---------- */
  const IDB_NAME = 'study-notes-idb-techstudy';
  const STORE_SQLITE = 'sqlite';
  const STORE_IMAGES = 'images';

  let idb;
  try {
    idb = await new Promise((resolve,reject)=>{
      if (!('indexedDB' in window)) return reject(new Error('IndexedDB not supported (Private mode?)'));
      const req = indexedDB.open(IDB_NAME, 1);
      req.onupgradeneeded = () => {
        const db=req.result;
        if(!db.objectStoreNames.contains(STORE_SQLITE)) db.createObjectStore(STORE_SQLITE);
        if(!db.objectStoreNames.contains(STORE_IMAGES)) db.createObjectStore(STORE_IMAGES);
      };
      req.onsuccess = ()=>resolve(req.result);
      req.onerror   = ()=>reject(req.error || new Error('IndexedDB open failed'));
    });
  } catch (e) {
    setStatus('IndexedDB error: ' + (e?.message || e), false);
    throw e;
  }
  const idbGet = (store,key)=> new Promise((res,rej)=>{
    const tx=idb.transaction(store,'readonly').objectStore(store).get(key);
    tx.onsuccess=()=>res(tx.result); tx.onerror=()=>rej(tx.error);
  });
  const idbSet = (store,key,value)=> new Promise((res,rej)=>{
    const tx=idb.transaction(store,'readwrite').objectStore(store).put(value,key);
    tx.onsuccess=()=>res(); tx.onerror=()=>rej(tx.error);
  });
  const idbDel = (store,key)=> new Promise((res,rej)=>{
    const tx=idb.transaction(store,'readwrite').objectStore(store).delete(key);
    tx.onsuccess=()=>res(); tx.onerror=()=>rej(tx.error);
  });

  /* ---------- Open / create SQLite DB ---------- */
  const raw = await idbGet(STORE_SQLITE, 'main');
  const db = raw ? new SQL.Database(raw instanceof Uint8Array ? raw : new Uint8Array(raw)) : new SQL.Database();

  db.exec(`
    PRAGMA foreign_keys=ON;
    create table if not exists subjects(
      id integer primary key,
      name text unique not null,
      created_at integer default (strftime('%s','now'))
    );
    create table if not exists topics(
      id integer primary key,
      subject_id integer not null references subjects(id) on delete cascade,
      name text not null,
      created_at integer default (strftime('%s','now'))
    );
    create table if not exists chunks(
      id integer primary key,
      topic_id integer not null references topics(id) on delete cascade,
      name text not null,
      created_at integer default (strftime('%s','now'))
    );
    create table if not exists notes(
      id integer primary key,
      scope text not null check(scope in ('topic','chunk')),
      scope_id integer not null,
      kind text not null check(kind in ('image','pdf')),
      title text,
      path text,
      url text,
      created_at integer default (strftime('%s','now'))
    );
    create index if not exists idx_notes_scope on notes(scope,scope_id);
    create table if not exists image_pages(
      id integer primary key,
      note_id integer not null references notes(id) on delete cascade,
      page integer not null,
      path text not null,
      created_at integer default (strftime('%s','now')),
      unique(note_id,page)
    );
    /* --- Auto-sync bookkeeping --- */
    create table if not exists sync_outbox(
      id integer primary key,
      doc_id text not null,
      doc_type text not null,
      action text not null check(action in ('upsert','delete')),
      payload text,
      created_at integer default (strftime('%s','now'))
    );
    create table if not exists sync_checkpoints(
      key text primary key,
      value text
    );
    create table if not exists rev_map(
      doc_id text primary key,
      rev text
    );
  `);

  let saveTimer;
  const saveDB = async ()=>{ await idbSet(STORE_SQLITE,'main',db.export()); setStatus('Saved ✓'); };
  const scheduleSave = ()=>{ clearTimeout(saveTimer); saveTimer=setTimeout(saveDB,250); };

  const driver = {
    exec(sql, bind){
      const st = db.prepare(sql);
      try{ if(bind) st.bind(bind); while(st.step()){} } finally{ st.free(); }
      scheduleSave();
    },
    select(sql, bind){
      const rows=[]; const st=db.prepare(sql);
      try{ if(bind) st.bind(bind); while(st.step()) rows.push(st.getAsObject()); }
      finally{ st.free(); }
      return rows;
    }
  };

  const writeBlob = async (path, blob)=> idbSet(STORE_IMAGES, path, blob);
  const rmFile   = async (path)=> idbDel(STORE_IMAGES, path);
  const readFile = async (path)=> idbGet(STORE_IMAGES, path);

  async function deleteImageNoteCascade(noteId){
    const head = driver.select(`select path from notes where id=?`, [noteId])[0];
    if(head?.path) await rmFile(head.path);
    const pages = driver.select(`select path from image_pages where note_id=?`, [noteId]);
    for(const p of pages) await rmFile(p.path);
    driver.exec(`delete from image_pages where note_id=?`, [noteId]);
    driver.exec(`delete from notes where id=?`, [noteId]);
  }

  /* ---------- collapse state ---------- */
  const collapsed = {
    subjects: new Set(JSON.parse(localStorage.getItem('coll-subjects')||'[]')),
    topics:   new Set(JSON.parse(localStorage.getItem('coll-topics')||'[]'))
  };
  const saveCollapse = () => {
    localStorage.setItem('coll-subjects', JSON.stringify([...collapsed.subjects]));
    localStorage.setItem('coll-topics',   JSON.stringify([...collapsed.topics]));
  };

  /* ---------- SYNC helpers ---------- */
  function queue(doc_id, doc_type, action, obj){
    driver.exec(`insert into sync_outbox(doc_id,doc_type,action,payload) values(?,?,?,?)`,
      [doc_id, doc_type, action, obj?JSON.stringify(obj):null]);
  }
  function setRev(doc_id, rev){
    driver.exec(`insert into rev_map(doc_id,rev) values(?,?)
                 on conflict(doc_id) do update set rev=excluded.rev`, [doc_id, rev]);
  }
  function getRev(doc_id){
    const r = driver.select(`select rev from rev_map where doc_id=?`, [doc_id])[0];
    return r?.rev || null;
  }
  function getSince(){
    const r = driver.select(`select value from sync_checkpoints where key='since'`)[0];
    return r?.value || '0';
  }
  function setSince(v){
    driver.exec(`insert into sync_checkpoints(key,value) values('since',?)
                 on conflict(key) do update set value=excluded.value`, [v]);
  }

  /* ---------- UI refs ---------- */
  const subjectsEl = document.getElementById('subjects');
  const details = {
    scope:null, id:null,
    titleEl: document.getElementById('detailTitle'),
    tagEl: document.getElementById('scopeTag'),
    bodyEl: document.getElementById('detailBody'),
    buttonsRow: document.getElementById('renameDeleteBtns'),
    imgInput: document.getElementById('imgInput'),
    imageList: document.getElementById('imageList'),
    pdfTitle: document.getElementById('pdfTitle'),
    pdfUrl: document.getElementById('pdfUrl'),
    pdfList: document.getElementById('pdfList')
  };

  function setDetail(scope,id,name){
    details.scope=scope; details.id=id;
    details.titleEl.textContent = name || '';
    details.tagEl.textContent = scope ? `${scope.toUpperCase()} DETAILS` : 'Nothing selected';
    details.bodyEl.style.display = scope ? '' : 'none';
    details.buttonsRow.style.display = scope ? '' : 'none';
    if(scope) loadNotes();
  }

  /* ---------- render tree ---------- */
  async function loadTree(){
    const subs = driver.select(`select id,name from subjects order by created_at asc`);
    subjectsEl.innerHTML='';
    for(const s of subs){
      const collapsedSubj = collapsed.subjects.has(s.id);
      const caret = collapsedSubj ? '▸' : '▾';
      const el=document.createElement('div'); el.className='subject'+(collapsedSubj?' collapsed':''); el.dataset.sid=s.id;
      el.innerHTML=`
        <header>
          <div class="row">
            <button class="iconbtn slim" data-act="toggle-subj" data-id="${s.id}"><span class="icon">${caret}</span></button>
            <h2>${esc(s.name)}</h2>
          </div>
          <div class="row">
            <button class="ghost slim" data-act="rename-subj" data-id="${s.id}">Rename</button>
            <button class="warn slim" data-act="del-subj" data-id="${s.id}">Delete</button>
          </div>
        </header>
        <div class="subject-body" id="subject-body-${s.id}">
          <div class="row">
            <input id="topic-input-${s.id}" type="text" placeholder="New topic name"/>
            <button class="slim" data-act="add-topic" data-id="${s.id}">+ Topic</button>
          </div>
          <div id="topic-list-${s.id}"></div>
        </div>`;
      subjectsEl.appendChild(el);
      await renderTopics(s.id);
    }
  }
  async function renderTopics(subjectId){
    const list = document.getElementById(`topic-list-${subjectId}`); if(!list) return;
    const topics = driver.select(`
      select t.id,t.name,(select count(*) from chunks c where c.topic_id=t.id) as chunks
      from topics t where t.subject_id=? order by t.created_at asc`, [subjectId]);
    list.innerHTML = topics.map(t=>{
      const collapsedTopic = collapsed.topics.has(t.id);
      const caret = collapsedTopic ? '▸' : '▾';
      return `
        <div class="topic ${collapsedTopic?'collapsed':''}" data-tid="${t.id}">
          <header>
            <div class="row">
              <button class="iconbtn slim" data-act="toggle-topic" data-id="${t.id}"><span class="icon">${caret}</span></button>
              <h3 data-act="open-topic" data-id="${t.id}">${esc(t.name)} <span class="small">(${t.chunks} chunks)</span></h3>
            </div>
            <div class="row">
              <button class="slim" data-act="add-chunk" data-id="${t.id}">+ Chunk</button>
              <button class="ghost slim" data-act="rename-topic" data-id="${t.id}">Rename</button>
              <button class="warn slim" data-act="del-topic" data-id="${t.id}">Delete</button>
            </div>
          </header>
          <div class="chunks" id="chunk-list-${t.id}"></div>
        </div>`;
    }).join('');
    for(const t of topics) await renderChunks(t.id);
  }
  async function renderChunks(topicId){
    const list = document.getElementById(`chunk-list-${topicId}`); if(!list) return;
    const chunks = driver.select(`select id,name from chunks where topic_id=? order by created_at asc`, [topicId]);
    list.innerHTML = chunks.map(c=>`
      <span class="chunk-pill" data-act="open-chunk" data-id="${c.id}">${esc(c.name)}</span>
      <button class="ghost slim" data-act="rename-chunk" data-id="${c.id}">Rename</button>
      <button class="warn slim" data-act="del-chunk" data-id="${c.id}">Delete</button>
    `).join('');
  }

  /* ---------- left pane actions + QUEUE ---------- */
  subjectsEl.addEventListener('click', async (e)=>{
    const el = e.target.closest('button, h3, .chunk-pill'); if(!el) return;
    const act = el.dataset.act, id = Number(el.dataset.id);
    try{
      if(act==='toggle-subj'){
        const card = el.closest('.subject'); const sid = Number(id);
        const collapsedNow = card.classList.toggle('collapsed');
        el.querySelector('.icon').textContent = collapsedNow ? '▸' : '▾';
        if(collapsedNow) collapsed.subjects.add(sid); else collapsed.subjects.delete(sid);
        saveCollapse();

      } else if(act==='toggle-topic'){
        const card = el.closest('.topic'); const tid =      Number(id);
      const collapsedNow = card.classList.toggle('collapsed');
      el.querySelector('.icon').textContent = collapsedNow ? '▸' : '▾';
      if (collapsedNow) collapsed.topics.add(tid); else collapsed.topics.delete(tid);
      saveCollapse();

    } else if (act === 'add-topic') {
      const sid = id;
      const inp = document.getElementById(`topic-input-${sid}`);
      const name = (inp.value || '').trim(); if (!name) return;
      driver.exec(`insert into topics(subject_id,name) values(?,?)`, [sid, name]);
      const tid = driver.select(`select last_insert_rowid() as id`)[0].id;
      queue(`topic:${tid}`, 'topic', 'upsert', { id: tid, subject_id: sid, name, created_at: Math.floor(Date.now()/1000) });
      await renderTopics(sid);

    } else if (act === 'rename-subj') {
      const [r] = driver.select(`select name from subjects where id=?`, [id]);
      const name = prompt('Rename subject', r?.name || ''); if (!name) return;
      driver.exec(`update subjects set name=? where id=?`, [name, id]);
      queue(`subject:${id}`, 'subject', 'upsert', { id, name, created_at: Math.floor(Date.now()/1000) });
      await loadTree();

    } else if (act === 'del-subj') {
      if (!confirm('Delete subject and everything under it?')) return;
      const topicIds = driver.select(`select id from topics where subject_id=?`, [id]).map(x => x.id);
      const chunkIds = driver.select(`select c.id from chunks c join topics t on c.topic_id=t.id where t.subject_id=?`, [id]).map(x => x.id);
      const noteIds  = driver.select(`
        select n.id from notes n
        where (n.scope='topic' and n.scope_id in (select id from topics where subject_id=?))
           or (n.scope='chunk' and n.scope_id in (select c.id from chunks c join topics t on c.topic_id=t.id where t.subject_id=?))
      `, [id, id]).map(x => x.id);
      for (const nid of noteIds) queue(`note:${nid}`, 'note', 'delete', null);
      for (const cid of chunkIds) queue(`chunk:${cid}`, 'chunk', 'delete', null);
      for (const tid of topicIds) queue(`topic:${tid}`, 'topic', 'delete', null);
      queue(`subject:${id}`, 'subject', 'delete', null);
      for (const nid of noteIds) await deleteImageNoteCascade(nid);
      driver.exec(`delete from subjects where id=?`, [id]);
      collapsed.subjects.delete(id); saveCollapse();
      await loadTree(); setDetail(null, null, '');

    } else if (act === 'rename-topic') {
      const [r] = driver.select(`select name,subject_id from topics where id=?`, [id]);
      const name = prompt('Rename topic', r?.name || ''); if (!name) return;
      driver.exec(`update topics set name=? where id=?`, [name, id]);
      queue(`topic:${id}`, 'topic', 'upsert', { id, subject_id: r.subject_id, name, created_at: Math.floor(Date.now()/1000) });
      await renderTopics(r.subject_id);
      if (details.scope === 'topic' && details.id === id) setDetail('topic', id, name);

    } else if (act === 'del-topic') {
      if (!confirm('Delete topic, its chunks & notes?')) return;
      const [r] = driver.select(`select subject_id from topics where id=?`, [id]);
      const chunkIds = driver.select(`select id from chunks where topic_id=?`, [id]).map(x => x.id);
      const noteIds  = driver.select(`
        select n.id from notes n
        where (n.scope='topic' and n.scope_id=?)
           or (n.scope='chunk' and n.scope_id in (select id from chunks where topic_id=?))
      `, [id, id]).map(x => x.id);
      for (const nid of noteIds) queue(`note:${nid}`, 'note', 'delete', null);
      for (const cid of chunkIds) queue(`chunk:${cid}`, 'chunk', 'delete', null);
      queue(`topic:${id}`, 'topic', 'delete', null);
      for (const nid of noteIds) await deleteImageNoteCascade(nid);
      driver.exec(`delete from topics where id=?`, [id]);
      collapsed.topics.delete(id); saveCollapse();
      await loadTree(); setDetail(null, null, '');

    } else if (act === 'add-chunk') {
      const topicId = id;
      const name = prompt('New chunk name'); if (!name) return;
      driver.exec(`insert into chunks(topic_id,name) values(?,?)`, [topicId, name]);
      const cid = driver.select(`select last_insert_rowid() as id`)[0].id;
      queue(`chunk:${cid}`, 'chunk', 'upsert', { id: cid, topic_id: topicId, name, created_at: Math.floor(Date.now()/1000) });
      await renderChunks(topicId);

    } else if (act === 'rename-chunk') {
      const [r] = driver.select(`select name,topic_id from chunks where id=?`, [id]);
      const name = prompt('Rename chunk', r?.name || ''); if (!name) return;
      driver.exec(`update chunks set name=? where id=?`, [name, id]);
      queue(`chunk:${id}`, 'chunk', 'upsert', { id, topic_id: r.topic_id, name, created_at: Math.floor(Date.now()/1000) });
      await renderChunks(r.topic_id);
      if (details.scope === 'chunk' && details.id === id) setDetail('chunk', id, name);

    } else if (act === 'del-chunk') {
      if (!confirm('Delete this chunk & its notes?')) return;
      const [r] = driver.select(`select topic_id from chunks where id=?`, [id]);
      const noteIds = driver.select(`select id from notes where kind in ('image','pdf') and scope='chunk' and scope_id=?`, [id]).map(x=>x.id);
      for (const nid of noteIds) queue(`note:${nid}`, 'note', 'delete', null);
      queue(`chunk:${id}`, 'chunk', 'delete', null);
      for (const nid of noteIds) await deleteImageNoteCascade(nid);
      driver.exec(`delete from chunks where id=?`, [id]);
      await renderChunks(r.topic_id); setDetail(null, null, '');

    } else if (act === 'open-topic') {
      const [r] = driver.select(`select name from topics where id=?`, [id]);
      setDetail('topic', id, r?.name || 'Topic');

    } else if (act === 'open-chunk') {
      const [r] = driver.select(`select name from chunks where id=?`, [id]);
      setDetail('chunk', id, r?.name || 'Chunk');
    }
  } catch (err) { alert(err.message); }
});

  /* ---------- top bar ---------- */
  const addSubject = () => {
    const name = (document.getElementById('newSubject').value || '').trim(); if (!name) return;
    driver.exec(`insert into subjects(name) values(?)`, [name]);
    const sid = driver.select(`select last_insert_rowid() as id`)[0].id;
    queue(`subject:${sid}`, 'subject', 'upsert', { id: sid, name, created_at: Math.floor(Date.now()/1000) });
    document.getElementById('newSubject').value = '';
    loadTree();
  };
  document.getElementById('addSubject').addEventListener('click', addSubject);
  document.getElementById('newSubject').addEventListener('keydown', e => { if (e.key === 'Enter') addSubject(); });

  /* ---------- detail: notes (existing) ---------- */
  // (Image handling + PDF list rendering already above)

  /* ---------- Notes UI (images + PDFs) + Lightbox (RESTORED) ---------- */

// helpers already defined earlier: driver, writeBlob, readFile, rmFile, deleteImageNoteCascade, queue
const imageList = document.getElementById('imageList');
const pdfList   = document.getElementById('pdfList');

/* Add PDF link */
document.getElementById('addPdf').addEventListener('click', ()=>{
  if (!details.scope) return;
  const title = (document.getElementById('pdfTitle').value || '').trim() || 'PDF';
  const url   = (document.getElementById('pdfUrl').value || '').trim();
  if (!url) return alert('Add a valid URL');
  driver.exec(`insert into notes(scope,scope_id,kind,title,url) values(?,?,?,?,?)`,
    [details.scope, details.id, 'pdf', title, url]);
  const nid = driver.select(`select last_insert_rowid() as id`)[0].id;
  queue(`note:${nid}`, 'note', 'upsert', {
    id:nid, scope:details.scope, scope_id:details.id,
    kind:'pdf', title, url, created_at:Math.floor(Date.now()/1000)
  });
  document.getElementById('pdfTitle').value='';
  document.getElementById('pdfUrl').value='';
  loadNotes();
});

/* Add new IMAGE note(s) */
document.getElementById('imgInput').addEventListener('change', async (e)=>{
  if (!details.scope) return;
  for (const f of [...e.target.files]) {
    const ext = (f.name.split('.').pop()||'png').toLowerCase();
    const id  = crypto.randomUUID();
    const previewPath = `/images/${details.scope}/${details.id}/${id}.${ext}`;
    await writeBlob(previewPath, f);
    driver.exec(`insert into notes(scope,scope_id,kind,title,path) values(?,?,?,?,?)`,
      [details.scope, details.id, 'image', f.name, previewPath]);
    const nid = driver.select(`select last_insert_rowid() as id`)[0].id;
    driver.exec(`insert into image_pages(note_id,page,path) values(?,?,?)`, [nid, 1, previewPath]);
    queue(`note:${nid}`, 'note', 'upsert', {
      id:nid, scope:details.scope, scope_id:details.id,
      kind:'image', title:f.name, path:previewPath, created_at:Math.floor(Date.now()/1000)
    });
  }
  e.target.value = '';
  loadNotes();
});

/* Render notes for current selection */
async function loadNotes(){
  imageList.innerHTML = '';
  pdfList.innerHTML   = '';

  // --- IMAGE notes
  const imgs = driver.select(`
    select id,title,path from notes
    where scope=? and scope_id=? and kind='image'
    order by id desc`, [details.scope, details.id]);

  for (const r of imgs) {
    let previewPath = r.path;
    const pages = driver.select(
      `select id,page,path from image_pages where note_id=? order by page asc`, [r.id]
    );
    if (pages.length) previewPath = pages[0].path;

    const prevBlob = await readFile(previewPath).catch(()=>null);
    const prevURL  = prevBlob ? URL.createObjectURL(prevBlob) : '';

    const card = document.createElement('div');
    card.className = 'card';
    card.dataset.noteid = r.id;
    card.innerHTML = `
      ${prevURL ? `<img class="preview" src="${prevURL}" alt="${esc(r.title||'image')}"/>` : `<div class="small">Missing image</div>`}
      <input type="text" value="${esc(r.title||'')}" placeholder="Caption" class="cap" data-id="${r.id}" style="margin-top:6px"/>
      <div class="row" style="margin-top:6px">
        <button class="ghost slim" data-act="save-cap" data-id="${r.id}">Save</button>
        <button class="warn slim" data-act="del-imgnote" data-id="${r.id}">Delete</button>
      </div>
      <div class="row" style="margin-top:6px;align-items:flex-start">
        <label class="filelabel slim" for="pages-${r.id}">+ Pages</label>
        <input id="pages-${r.id}" type="file" accept="image/*" multiple data-act="add-pages" data-id="${r.id}"/>
        <div class="thumbs" id="thumbs-${r.id}"></div>
      </div>`;
    imageList.appendChild(card);

    const thumbs = card.querySelector(`#thumbs-${r.id}`);
    for (const p of pages) {
      const b = await readFile(p.path).catch(()=>null);
      if (!b) continue;
      const u = URL.createObjectURL(b);
      const t = document.createElement('img');
      t.src = u; t.dataset.note = r.id; t.dataset.page = p.page;
      thumbs.appendChild(t);
    }
  }

  // --- PDF notes
  const pdfs = driver.select(`
    select id,title,url from notes
    where scope=? and scope_id=? and kind='pdf'
    order by id desc`, [details.scope, details.id]);

  for (const r of pdfs) {
    const row = document.createElement('div'); row.className = 'card';
    row.innerHTML = `
      <div class="row" style="justify-content:space-between">
        <input type="text" class="pdftitle" data-id="${r.id}" value="${esc(r.title||'PDF')}"/>
        <button class="ghost slim" data-act="save-pdf" data-id="${r.id}">Save</button>
      </div>
      <div class="row" style="margin-top:6px">
        <input type="url" class="pdfurl" data-id="${r.id}" value="${esc(r.url||'')}"/>
        <a class="link" href="${r.url||'#'}" target="_blank" rel="noopener">Open</a>
      </div>
      <div class="row" style="margin-top:6px">
        <button class="warn slim" data-act="del-pdf" data-id="${r.id}">Delete</button>
      </div>`;
    pdfList.appendChild(row);
  }
}

/* extra pages uploader */
imageList.addEventListener('change', async (e)=>{
  const fi = e.target.closest('input[type=file][data-act="add-pages"]');
  if (!fi) return;
  const noteId = Number(fi.dataset.id);
  let next = driver.select(`select coalesce(max(page),0)+1 as n from image_pages where note_id=?`, [noteId])[0].n;
  for (const f of [...fi.files]) {
    const ext  = (f.name.split('.').pop()||'png').toLowerCase();
    const id   = crypto.randomUUID();
    const path = `/images/n${noteId}/${id}.${ext}`;
    await writeBlob(path, f);
    driver.exec(`insert into image_pages(note_id,page,path) values(?,?,?)`, [noteId, next++, path]);
  }
  const n = driver.select(`select id,scope,scope_id,kind,title,path,url,created_at from notes where id=?`, [noteId])[0];
  if (n) queue(`note:${n.id}`, 'note', 'upsert', n);
  fi.value = '';
  loadNotes();
});

/* image card actions + lightbox open */
imageList.addEventListener('click', async (e)=>{
  const btn = e.target.closest('button');
  const noteCard = e.target.closest('.card');
  if (btn) {
    const id = Number(btn.dataset.id);
    if (btn.dataset.act === 'save-cap') {
      const cap = noteCard.querySelector('input.cap').value;
      driver.exec(`update notes set title=? where id=?`, [cap, id]);
      const n = driver.select(`select id,scope,scope_id,kind,title,path,url,created_at from notes where id=?`, [id])[0];
      if (n) queue(`note:${n.id}`, 'note', 'upsert', n);
    } else if (btn.dataset.act === 'del-imgnote') {
      if (!confirm('Delete this image note (and all its pages)?')) return;
      queue(`note:${id}`, 'note', 'delete', null);
      await deleteImageNoteCascade(id);
      loadNotes();
    }
    return;
  }
  if (e.target.matches('.thumbs img')) {
    openLightboxForNote(Number(e.target.dataset.note), Number(e.target.dataset.page));
    return;
  }
  if (e.target.matches('img.preview')) {
    openLightboxForNote(Number(noteCard.dataset.noteid), 1);
  }
});

/* PDF save/delete */
pdfList.addEventListener('click', async (e)=>{
  const b = e.target.closest('button'); if (!b) return;
  const id = Number(b.dataset.id);
  if (b.dataset.act === 'save-pdf') {
    const card  = b.closest('.card');
    const title = card.querySelector('.pdftitle').value;
    const url   = card.querySelector('.pdfurl').value;
    driver.exec(`update notes set title=?, url=? where id=?`, [title, url, id]);
    const n = driver.select(`select id,scope,scope_id,kind,title,path,url,created_at from notes where id=?`, [id])[0];
    if (n) queue(`note:${n.id}`, 'note', 'upsert', n);
  } else if (b.dataset.act === 'del-pdf') {
    if (!confirm('Delete PDF link?')) return;
    queue(`note:${id}`, 'note', 'delete', null);
    driver.exec(`delete from notes where id=?`, [id]);
    loadNotes();
  }
});

/* ---------- Lightbox (restored) ---------- */
const lbEl    = document.getElementById('lightbox');
const lbStack = document.getElementById('lbStack');
const lbClose = document.querySelector('.lightbox-close');
const lbVP    = lbEl.querySelector('.viewport');
let lbZoom = 1;
function lbUpdateZoom(){
  if (lbZoom===1){ lbEl.classList.remove('zoomed'); lbStack.style.setProperty('--z','1'); lbVP.scrollTop=lbVP.scrollLeft=0; }
  else { lbEl.classList.add('zoomed'); lbStack.style.setProperty('--z', String(lbZoom)); }
}
function lbCloseAll(){ lbEl.classList.remove('show','zoomed'); lbEl.setAttribute('aria-hidden','true'); lbStack.innerHTML=''; lbZoom=1; }
lbClose.addEventListener('click', ()=>{ if(lbZoom>1){ lbZoom=1; lbUpdateZoom(); } else lbCloseAll(); });
lbEl.addEventListener('click', (e)=>{ if(e.target===lbEl) lbCloseAll(); });
lbVP.addEventListener('click', (e)=>{ if(e.target===lbVP) lbCloseAll(); });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') lbCloseAll(); });

async function openLightboxForNote(noteId, startPage=1){
  const note  = driver.select(`select title from notes where id=?`, [noteId])[0];
  const pages = driver.select(`select page,path from image_pages where note_id=? order by page asc`, [noteId]);
  if (!pages.length) {
    const head = driver.select(`select path from notes where id=?`, [noteId])[0];
    if (!head?.path) return;
    pages.push({page:1, path:head.path});
  }
  lbStack.innerHTML = '';
  for (const p of pages) {
    const b = await readFile(p.path).catch(()=>null);
    if (!b) continue;
    const u = URL.createObjectURL(b);
    const im = document.createElement('img');
    im.src = u;
    im.alt = (note?.title||'image') + ` · p${p.page}`;
    im.id  = `p${p.page}`;
    lbStack.appendChild(im);
  }
  lbEl.classList.add('show'); lbEl.setAttribute('aria-hidden','false'); lbZoom=1; lbUpdateZoom();
  const tgt = document.getElementById(`p${startPage}`); if (tgt) tgt.scrollIntoView({block:'start', behavior:'instant'});
}

  /* ---------- Intercept "Open" to use chunked viewer (Google Drive or direct PDF) ---------- */
  // Robust PDF.js loader (local → CDN fallback)
  async function loadPdfJs() {
    try {
      const mod = await import('/lib/pdfjs/pdf.mjs');
      return { pdfjsLib: mod, workerSrc: '/lib/pdfjs/pdf.worker.mjs' };
    } catch {
      const base = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/';
      const mod = await import(base + 'pdf.mjs');
      return { pdfjsLib: mod, workerSrc: base + 'pdf.worker.mjs' };
    }
  }

  function extractDriveId(s) {
    if (!s) return '';
    if (/^[A-Za-z0-9_-]{20,}$/.test(s)) return s; // raw ID
    try {
      const u = new URL(s);
      const m1 = u.pathname.match(/\/file\/d\/([^/]+)/); if (m1) return m1[1];
      return u.searchParams.get('id') || '';
    } catch { return ''; }
  }

  async function openPdfInModal(title, urlOrId) {
    const id = extractDriveId(urlOrId);
    const src = id ? `/drivepdf/${id}` : urlOrId;

    const { pdfjsLib, workerSrc } = await loadPdfJs();
    pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;

    const modal = document.getElementById('pdfModal');
    const viewer = document.getElementById('pdfViewer');
    const titleBar = document.getElementById('pdfTitleBar');
    const metaEl = document.getElementById('pdfMeta');
    const closeBtn = document.getElementById('pdfClose');

    viewer.innerHTML = ''; modal.style.display = 'block';
    titleBar.textContent = title || 'PDF'; metaEl.textContent = 'Loading…';

    const loadingTask = pdfjsLib.getDocument({
      url: src,
      disableStream: false,
      disableAutoFetch: true,
      rangeChunkSize: 4 * 1024 * 1024
    });

    const pdf = await loadingTask.promise;
    metaEl.textContent = `${pdf.numPages} pages`;

    const BATCH = 10, SCALE = 1.5;
    const pageIO = new IntersectionObserver(async (entries) => {
      for (const e of entries) {
        const el = e.target;
        if (!e.isIntersecting || el.dataset.rendered) continue;
        const n = +el.dataset.page;
        const page = await pdf.getPage(n);
        const vp = page.getViewport({ scale: SCALE });
        const canvas = el.querySelector('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: false });
        const ratio = Math.min(2, devicePixelRatio || 1);
        canvas.width  = Math.floor(vp.width * ratio);
        canvas.height = Math.floor(vp.height * ratio);
        canvas.style.width = vp.width + 'px';
        canvas.style.height = vp.height + 'px';
        await page.render({ canvasContext: ctx, viewport: vp }).promise;
        el.dataset.rendered = '1';
      }
    }, { root: viewer, rootMargin: '1000px 0px' });

    const batchIO = new IntersectionObserver((entries) => {
      for (const e of entries) {
        if (!e.isIntersecting) continue;
        const next = +e.target.dataset.nextBatch;
        appendBatch(next);
        batchIO.unobserve(e.target);
      }
    }, { root: viewer, rootMargin: '1200px 0px' });

    function pageShell(n) {
      const d = document.createElement('div');
      d.className = 'page';
      d.dataset.page = n;
      d.innerHTML = '<canvas></canvas>';
      pageIO.observe(d);
      return d;
    }
    function sentinel(next) {
      const s = document.createElement('div');
      s.className = 'sentinel';
      s.dataset.nextBatch = next;
      s.textContent = 'Loading more pages…';
      batchIO.observe(s);
      return s;
    }
    async function appendBatch(i) {
      const start = i * BATCH + 1;
      const end = Math.min(start + BATCH - 1, pdf.numPages);
      if (start > pdf.numPages) return;
      const frag = document.createDocumentFragment();
      for (let p = start; p <= end; p++) frag.appendChild(pageShell(p));
      if (end < pdf.numPages) frag.appendChild(sentinel(i + 1));
      viewer.appendChild(frag);
    }

    appendBatch(0);
    closeBtn.onclick = () => { modal.style.display = 'none'; viewer.innerHTML = ''; };
  }

  // Intercept the "Open" anchor in each PDF card to use the modal viewer
  document.getElementById('pdfList').addEventListener('click', (e) => {
    const a = e.target.closest('a.link'); if (!a) return;
    e.preventDefault();
    const card = a.closest('.card');
    const title = (card.querySelector('.pdftitle')?.value || 'PDF').trim();
    const url = (card.querySelector('.pdfurl')?.value || a.getAttribute('href') || '').trim();
    if (!url) return;
    openPdfInModal(title, url);
  });

  /* ---------- Image lightbox + CouchDB sync sections remain as in your file ---------- */
  // (No changes needed here — your existing code below this point can remain.)

  /* ---------- CouchDB Sync (Save/Test/Sync + Pull) ---------- */
const couchCfgKey = 'couchCfg-techstudy';
const couchMsgEl  = document.getElementById('couchMsg');

const couch = {
  cfg: JSON.parse(localStorage.getItem(couchCfgKey) || '{}'),
  save(){ localStorage.setItem(couchCfgKey, JSON.stringify(this.cfg)); },
  base(){
    if(!this.cfg.url || !this.cfg.db) throw new Error('Set Couch URL and DB first.');
    return this.cfg.url.replace(/\/+$/,'') + '/' + encodeURIComponent(this.cfg.db);
  },
  authHeader(){
    if (this.cfg.user && this.cfg.pass) return 'Basic ' + btoa(this.cfg.user + ':' + this.cfg.pass);
    return null;
  },
  async ensureDb(){
    const r = await fetch(this.base(), {
      method: 'GET',
      headers: this.authHeader() ? { Authorization: this.authHeader() } : {},
      credentials: 'include'
    });
    if (r.status === 404) throw new Error('DB not found. Create it once on the server.');
    if (!r.ok) throw new Error(await r.text());
    return r.json().catch(()=>null);
  },
  async fetchJson(path, opts = {}){
    const headers = Object.assign(
      { 'Accept': 'application/json' },
      opts.headers || {},
      this.authHeader() ? { 'Authorization': this.authHeader() } : {}
    );
    const res = await fetch(this.base() + path, { ...opts, headers, credentials: 'include' });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  }
};

// Prefill sensible defaults once
if (!couch.cfg.url && !couch.cfg.db) {
  couch.cfg = { url: 'https://couch.techstudy.me', db: 'engineering', user: '' };
  couch.save();
}
// hydrate form on load
(function hydrateCouchForm(){
  document.getElementById('couchUrl').value  = couch.cfg.url  || '';
  document.getElementById('couchDb').value   = couch.cfg.db   || '';
  document.getElementById('couchUser').value = couch.cfg.user || '';
  document.getElementById('couchPass').value = '';
})();

// Button: Save
document.getElementById('couchSave').addEventListener('click', ()=>{
  couch.cfg.url  = document.getElementById('couchUrl').value.trim();
  couch.cfg.db   = document.getElementById('couchDb').value.trim();
  couch.cfg.user = document.getElementById('couchUser').value.trim();
  const pw       = document.getElementById('couchPass').value;
  if (pw) couch.cfg.pass = pw;
  couch.save();
  couchMsgEl.textContent = 'Saved Couch settings.';
});

// Button: Test
document.getElementById('couchTest').addEventListener('click', async ()=>{
  try {
    const info = (await couch.ensureDb()) || (await couch.fetchJson(''));
    couchMsgEl.textContent = `OK: ${info.db_name} (doc count ${info.doc_count})`;
  } catch (err) {
    couchMsgEl.textContent = 'Test failed: ' + err.message;
  }
});

// Minimal “Sync now” (push all local docs to CouchDB)
document.getElementById('couchSync').addEventListener('click', async ()=>{
  try{
    couchMsgEl.textContent = 'Syncing…';
    await couch.ensureDb();

    // subjects/topics/chunks
    for (const s of driver.select(`select id,name,created_at from subjects`)) {
      await couch.fetchJson('/'+encodeURIComponent(`subject:${s.id}`), {
        method:'PUT', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ _id:`subject:${s.id}`, type:'subject', ...s })
      });
    }
    for (const t of driver.select(`select id,subject_id,name,created_at from topics`)) {
      await couch.fetchJson('/'+encodeURIComponent(`topic:${t.id}`), {
        method:'PUT', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ _id:`topic:${t.id}`, type:'topic', ...t })
      });
    }
    for (const c of driver.select(`select id,topic_id,name,created_at from chunks`)) {
      await couch.fetchJson('/'+encodeURIComponent(`chunk:${c.id}`), {
        method:'PUT', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ _id:`chunk:${c.id}`, type:'chunk', ...c })
      });
    }
    // notes (metadata only; images/attachments can be added later)
    for (const n of driver.select(`select id,scope,scope_id,kind,title,path,url,created_at from notes`)) {
      await couch.fetchJson('/'+encodeURIComponent(`note:${n.id}`), {
        method:'PUT', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ _id:`note:${n.id}`, type:'note', ...n })
      });
    }

    const info = await couch.fetchJson('');
    couchMsgEl.textContent = `Sync done. Docs: ${info.doc_count}`;
  }catch(err){
    couchMsgEl.textContent = 'Sync failed: ' + err.message;
  }
});

// Minimal “Pull now” (refreshes from _all_docs; simple merge)
document.getElementById('couchPull').addEventListener('click', async ()=>{
  try{
    await couch.ensureDb();
    const all = await couch.fetchJson('/_all_docs?include_docs=true');
    for (const row of all.rows) {
      const doc = row.doc; if (!doc || doc._deleted) continue;
      if (doc.type === 'subject') {
        driver.exec(`insert into subjects(id,name,created_at) values(?,?,?)
          on conflict(id) do update set name=excluded.name, created_at=excluded.created_at`,
          [doc.id, doc.name, doc.created_at||Math.floor(Date.now()/1000)]);
      } else if (doc.type === 'topic') {
        driver.exec(`insert into topics(id,subject_id,name,created_at) values(?,?,?,?)
          on conflict(id) do update set subject_id=excluded.subject_id, name=excluded.name, created_at=excluded.created_at`,
          [doc.id, doc.subject_id, doc.name, doc.created_at||Math.floor(Date.now()/1000)]);
      } else if (doc.type === 'chunk') {
        driver.exec(`insert into chunks(id,topic_id,name,created_at) values(?,?,?,?)
          on conflict(id) do update set topic_id=excluded.topic_id, name=excluded.name, created_at=excluded.created_at`,
          [doc.id, doc.topic_id, doc.name, doc.created_at||Math.floor(Date.now()/1000)]);
      } else if (doc.type === 'note') {
        driver.exec(`insert into notes(id,scope,scope_id,kind,title,path,url,created_at)
          values(?,?,?,?,?,?,?,?)
          on conflict(id) do update set scope=excluded.scope, scope_id=excluded.scope_id, kind=excluded.kind,
            title=excluded.title, path=excluded.path, url=excluded.url, created_at=excluded.created_at`,
          [doc.id, doc.scope, doc.scope_id, doc.kind, doc.title||'', doc.path||'', doc.url||'', doc.created_at||Math.floor(Date.now()/1000)]);
      }
    }
    couchMsgEl.textContent = 'Pulled changes.';
    loadTree();
  }catch(err){
    couchMsgEl.textContent = 'Pull failed: ' + err.message;
  }
});

  /* init */
  setStatus('DB: OK (IndexedDB)');
  loadTree();

  // If you already had auto-sync helpers below, keep them as-is.
  // (Not repeated here to avoid duplicating your existing logic.)
})();
</script>
